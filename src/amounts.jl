#----------------------------------------------------------------------------------------------#
#                                    Amount Type Interface                                     #
#----------------------------------------------------------------------------------------------#

"""
`function deco end`\n
Interface to return a unique decorative `Symbol` from a method's argument type.
"""
function deco end

"""
`function ppu end`\n
Interface to pretty-print units.
"""
function ppu end

export deco, ppu


#----------------------------------------------------------------------------------------------#
#                                     Generic Amount Type                                      #
#----------------------------------------------------------------------------------------------#

import Base: cp, convert

"""
`struct _Amt{ùóΩ<:PREC,ùòÖ<:EXAC} <: AMOUNTS{ùóΩ,ùòÖ}`\n
Precision-, and Exactness- parametric generic amounts in arbitrary units.\n
`_Amt{ùóΩ,ùòÖ}` parameters are:\n
- Precision `ùóΩ<:Union{Float16,Float32,Float64,BigFloat}`;\n
- Exactness `ùòÖ<:Union{EX,MM}`, i.e., either a single, precise value or an uncertainty-bearing
  measurement, respectively;\n
A `_Amt` can be natively constructed from the following argument types:\n
- A plain, unitless float;\n
- A plain, unitless `Measurement`; hence, any `AbstractFloat`;\n
- A `Quantity{AbstractFloat}` with any units.\n
## Hierarchy\n
`_Amt <: $(tyArchy(AMOUNTS))`
"""
struct _Amt{ùóΩ,ùòÖ} <: GenericAmt{ùóΩ,ùòÖ}
    amt::UATY{ùóΩ} where ùóΩ<:PREC
    # Copy constructor
    _Amt(x::_Amt{ùóΩ,ùòÖ}) where {ùóΩ<:PREC,ùòÖ<:EXAC} = new{ùóΩ,ùòÖ}(x.amt)
    _Amt(x::Union{ùóΩ,UETY{ùóΩ}}) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x))
    _Amt(x::Union{PMTY{ùóΩ},UMTY{ùóΩ}}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(x))
end

# Precision-changing external constructors
(::Type{_Amt{ùòÄ}})(x::_Amt{ùóΩ,EX}
                 ) where {ùòÄ<:PREC,ùóΩ<:PREC} = _Amt(ùòÄ(x.amt.val))
(::Type{_Amt{ùòÄ}})(x::_Amt{ùóΩ,MM}
                 ) where {ùòÄ<:PREC,ùóΩ<:PREC} = _Amt(Measurement{ùòÄ}(x.amt.val))

# Precision+Exactness-changing external constructors
(::Type{_Amt{ùòÄ,EX}})(x::_Amt{ùóΩ,EX}
                    ) where {ùòÄ<:PREC,ùóΩ<:PREC} = _Amt(ùòÄ(x.amt.val))
(::Type{_Amt{ùòÄ,EX}})(x::_Amt{ùóΩ,MM}
                    ) where {ùòÄ<:PREC,ùóΩ<:PREC} = _Amt(ùòÄ(x.amt.val.val))
(::Type{_Amt{ùòÄ,MM}})(x::_Amt{ùóΩ,EX},
                     e::ùòÄ=ùòÄ(max(eps(ùòÄ),eps(x.amt.val)))
                    ) where {ùòÄ<:PREC,ùóΩ<:PREC} = _Amt(measurement(ùòÄ(x.amt.val), e))
(::Type{_Amt{ùòÄ,MM}})(x::_Amt{ùóΩ,MM}
                    ) where {ùòÄ<:PREC,ùóΩ<:PREC} = _Amt(Measurement{ùòÄ}(x.amt.val))

# Type export
export _Amt

# Type-specific functions
deco(x::_Amt{ùóΩ,ùòÖ} where {ùóΩ,ùòÖ}) = Symbol("?")
ppu(x::_Amt) = "$(unit(x.amt))"

# Conversions
convert(::Type{_Amt{ùòÄ,ùòÖ}},
        y::_Amt{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÖ<:EXAC} = begin
    _Amt{promote_type(ùòÄ,ùóΩ),ùòÖ}(y)
end
convert(::Type{_Amt{ùòÄ,ùòÜ}},
        y::_Amt{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
    _Amt{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}(y)
end

# Promotion rules
promote_rule(::Type{_Amt{ùòÄ,ùòÜ}},
             ::Type{_Amt{ùóΩ,ùòÖ}}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
    _Amt{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}
end


#----------------------------------------------------------------------------------------------#
#                                  Whole Amount Type Factory                                   #
#----------------------------------------------------------------------------------------------#

import Unicode: normalize

"""
Whole Amount type factory.
"""
function mkWhlAmt(TYPE::Symbol,         # Type name:            :sysT
                  SUPT::Symbol,         # Supertype:            :WProperty
                  FNAM::Symbol,         # Function Name:        :T
                  SYMB::AbstractString, # Printing symbol:      "T"
                  UNIT::Unitful.Units,  # SY quantity units:    u"K"
                  USTR::AbstractString, # PrettyPrinting units: "K"
                  WHAT::AbstractString, # Description:          "temperature"
                  DELT::Bool=false,     # Whether a Œî quantity
                 )
    # Constants
    uSY = UNIT
    ùë¢SY = typeof(uSY)
    ùëëSY = dimension(uSY)
    i, f = DELT ? (3, 4) : (1, 2)
    ùë†SY = normalize((DELT ? "Œî" : "") * string(SYMB))
    # Documentation
    hiStr = tyArchy(eval(SUPT))
    dcStr = """
`struct $TYPE{ùóΩ<:PREC,ùòÖ<:EXAC} <: $SUPT{ùóΩ,ùòÖ}`\n
Precision-, and Exactness- parametric $WHAT amounts based in $USTR.\n
`$TYPE{ùóΩ,ùòÖ}` parameters are:\n
- Precision `ùóΩ<:Union{Float16,Float32,Float64,BigFloat}`;\n
- Exactness `ùòÖ<:Union{EX,MM}`, i.e., either a single, precise value or an uncertainty-bearing
  measurement, respectively;\n
A `$TYPE` can be natively constructed from the following argument types:\n
- A plain, unitless float;\n
- A plain, unitless `Measurement`; hence, any `AbstractFloat`;\n
- A `Quantity{AbstractFloat}` with compatible units.\n
Constructors determine all parameters from their arguments.\n
## Hierarchy\n
`$(TYPE) <: $(hiStr)`
    """
    # @eval block
    @eval begin
        # Concrete type definition
        struct $TYPE{ùóΩ,ùòÖ} <: $SUPT{ùóΩ,ùòÖ}
            amt::UATY{ùóΩ,$ùëëSY,$ùë¢SY} where ùóΩ<:PREC
            # Copy constructor
            $TYPE(x::$TYPE{ùóΩ,ùòÖ}) where {ùóΩ<:PREC,ùòÖ<:EXAC} = new{ùóΩ,ùòÖ}(x.amt)
            # Plain constructors enforce default units & avoid unit conversion
            $TYPE(x::ùóΩ) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x * $uSY))
            $TYPE(x::PMTY{ùóΩ}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(x * $uSY))
            # Quantity constructors have to perform unit conversion despite matching dimensions
            $TYPE(x::UETY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(uconvert($uSY, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(uconvert($uSY, x)))
        end
        # Type documentation
        @doc $dcStr $TYPE
        # Precision-changing external constructors
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,EX}
                          ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(ùòÄ(x.amt.val))
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,MM}
                          ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(Measurement{ùòÄ}(x.amt.val))
        # Precision+Exactness-changing external constructors
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,EX}
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(ùòÄ(x.amt.val))
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,MM}
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(ùòÄ(x.amt.val.val))
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,EX},
                              e::ùòÄ=ùòÄ(max(eps(ùòÄ),eps(x.amt.val)))
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(measurement(ùòÄ(x.amt.val), e))
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,MM}
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(Measurement{ùòÄ}(x.amt.val))
        # Type export
        export $TYPE
        # Type-specific functions
        deco(x::$TYPE{ùóΩ,ùòÖ} where {ùóΩ,ùòÖ}) = Symbol($ùë†SY)
        ppu(x::$TYPE{ùóΩ,ùòÖ} where {ùóΩ,ùòÖ}) = $USTR
        # Indirect construction from plain
        $FNAM(x::plnF) = $TYPE(x)
        $FNAM(x::plnR) = $TYPE(float(x))
        # Indirect construction from quantity
        $FNAM(x::UATY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = $TYPE(x)
        $FNAM(x::uniR{ùóΩ,$ùëëSY}) where ùóΩ<:REAL = $TYPE(float(x.val) * unit(x))
        export $FNAM
        # Conversions
        convert(::Type{$TYPE{ùòÄ,ùòÖ}},
                y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),ùòÖ}(y)
        end
        convert(::Type{$TYPE{ùòÄ,ùòÜ}},
                y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}(y)
        end
        # Promotion rules
        promote_rule(::Type{$TYPE{ùòÄ,ùòÜ}},
                     ::Type{$TYPE{ùóΩ,ùòÖ}}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}
        end
    end
end


#----------------------------------------------------------------------------------------------#
#                           Thermodynamic Whole Amount Declarations                            #
#----------------------------------------------------------------------------------------------#

# Regular properties -- \bb#<TAB> velocity/speed function names
mkWhlAmt(:sysT  , :WProperty, :T    , "T"   , u"K"          , "K"       , "temperature"         , false )
mkWhlAmt(:sysP  , :WProperty, :P    , "P"   , u"kPa"        , "kPa"     , "pressure"            , false )
mkWhlAmt(:VELO  , :WProperty, :velo , "ùïç"   , u"‚àö(kJ/kg)"   , "‚àökJ/kg"  , "velocity"            , false )
mkWhlAmt(:SPEE  , :WProperty, :spee , "ùïß"   , u"m/s"        , "m/s"     , "speed"               , false )

# Regular unranked -- \sans#<TAB> function names
mkWhlAmt(:time  , :WUnranked, :time , "ùóç"   , u"s"          , "s"       , "time"                , false )
mkWhlAmt(:grav  , :WUnranked, :grav , "ùóÄ"   , u"m/s^2"      , "m/s¬≤"    , "gravity"             , false )
mkWhlAmt(:alti  , :WUnranked, :alti , "ùóì"   , u"m"          , "m"       , "altitude"            , false )


#----------------------------------------------------------------------------------------------#
#                                  Based Amount Type Factory                                   #
#----------------------------------------------------------------------------------------------#

"""
Based Amount type factory.
"""
function mkBasAmt(TYPE::Symbol,         # Type Name:            :uAmt
                  SUPT::Symbol,         # Supertype:            :BProperty
                  FNAM::Symbol,         # Function Name:        :u
                  SYMB::AbstractString, # Printing symbol:      "U"
                  UNIT::Unitful.Units,  # SY quantity units:    u"kJ"
                  USTR::AbstractString, # PrettyPrinting units: "K"
                  WHAT::AbstractString, # Description:          "internal energy"
                  DELT::Bool=false;     # Whether a Œî quantity
                  bsym::NTuple{4,Symbol}=(:none,:none,:none,:none)
                 )
    # Constants
    uSY = UNIT
    uDT = UNIT / u"s"
    uMA = UNIT / u"kg"
    uMO = UNIT / u"kmol"
    ùë¢SY = typeof(uSY)
    ùë¢DT = typeof(uDT)
    ùë¢MA = typeof(uMA)
    ùë¢MO = typeof(uMO)
    ùëëSY = dimension(uSY)
    ùëëDT = dimension(uDT)
    ùëëMA = dimension(uMA)
    ùëëMO = dimension(uMO)
    i, f = DELT ? (3, 4) : (1, 2)
    ùë†SY = bsym[1] == :none ?
        normalize((DELT ? "Œî" : "") * uppercase(string(SYMB))) :
        string(bsym[1])
    ùë†DT = bsym[2] == :none ?
        normalize(string(ùë†SY[1:i], "\u0307", ùë†SY[f:end])) :
        string(bsym[2])
    ùë†MA = bsym[3] == :none ?
        normalize((DELT ? "Œî" : "") * lowercase(string(SYMB))) :
        string(bsym[3])
    ùë†MO = bsym[4] == :none ?
        normalize(string(ùë†MA[1:i], "\u0304", ùë†MA[f:end])) :
        string(bsym[4])
    # Documentation
    hiStr = tyArchy(eval(SUPT))
    dcStr = """
`struct $TYPE{ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE} <: $SUPT{ùóΩ,ùòÖ,ùóØ}`\n
Precision-, Exactness-, and Base- parametric $WHAT amounts based in $USTR.\n
`$TYPE{ùóΩ,ùòÖ,ùóØ}` parameters are:\n
- Precision `ùóΩ<:Union{Float16,Float32,Float64,BigFloat}`;\n
- Exactness `ùòÖ<:Union{EX,MM}`, i.e., either a single, precise value or an uncertainty-bearing
  measurement, respectively;\n
- Thermodynamic base `ùóØ<:Union{SY,DT,MA,MO}` respectively for system, rate, mass, or molar
  quantities, respectively in units of $(uSY), $(uDT), $(uMA), or $(uMO).\n
A `$TYPE` can be natively constructed from the following argument types:\n
- A plain, unitless float;\n
- A plain, unitless `Measurement`; hence, any `AbstractFloat`;\n
- A `Quantity{AbstractFloat}` with compatible units.\n
Constructors determine parameters from their arguments. `Quantity` constructors do not need a
base argument. Plain, `AbstractFloat` ones require the base argument.\n
## Hierarchy\n
`$(TYPE) <: $(hiStr)`
    """
    # @eval block
    @eval begin
        # Concrete type definition
        struct $TYPE{ùóΩ,ùòÖ,ùóØ} <: $SUPT{ùóΩ,ùòÖ,ùóØ}
            amt::Union{UATY{ùóΩ,$ùëëSY,$ùë¢SY},UATY{ùóΩ,$ùëëDT,$ùë¢DT},
                       UATY{ùóΩ,$ùëëMA,$ùë¢MA},UATY{ùóΩ,$ùëëMO,$ùë¢MO}} where ùóΩ<:PREC
            # Copy constructor
            $TYPE(x::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE} = new{ùóΩ,ùòÖ,ùóØ}(x.amt)
            # Plain constructors enforce default units & avoid unit conversion
            # Plain Exact (ùóΩ<:PREC) float constructors
            $TYPE(x::ùóΩ, ::Type{SY}) where ùóΩ<:PREC = new{ùóΩ,EX,SY}(_qty(x * $uSY))
            $TYPE(x::ùóΩ, ::Type{DT}) where ùóΩ<:PREC = new{ùóΩ,EX,DT}(_qty(x * $uDT))
            $TYPE(x::ùóΩ, ::Type{MA}) where ùóΩ<:PREC = new{ùóΩ,EX,MA}(_qty(x * $uMA))
            $TYPE(x::ùóΩ, ::Type{MO}) where ùóΩ<:PREC = new{ùóΩ,EX,MO}(_qty(x * $uMO))
            # Plain Measurement (PMTY) constructors
            $TYPE(x::PMTY{ùóΩ}, ::Type{SY}) where ùóΩ<:PREC = new{ùóΩ,MM,SY}(_qty(x * $uSY))
            $TYPE(x::PMTY{ùóΩ}, ::Type{DT}) where ùóΩ<:PREC = new{ùóΩ,MM,DT}(_qty(x * $uDT))
            $TYPE(x::PMTY{ùóΩ}, ::Type{MA}) where ùóΩ<:PREC = new{ùóΩ,MM,MA}(_qty(x * $uMA))
            $TYPE(x::PMTY{ùóΩ}, ::Type{MO}) where ùóΩ<:PREC = new{ùóΩ,MM,MO}(_qty(x * $uMO))
            # Quantity constructors have to perform unit conversion despite matching dimensions
            # United Exact (UETY) constructors
            $TYPE(x::UETY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,EX,SY}(_qty(uconvert($uSY, x)))
            $TYPE(x::UETY{ùóΩ,$ùëëDT}) where ùóΩ<:PREC = new{ùóΩ,EX,DT}(_qty(uconvert($uDT, x)))
            $TYPE(x::UETY{ùóΩ,$ùëëMA}) where ùóΩ<:PREC = new{ùóΩ,EX,MA}(_qty(uconvert($uMA, x)))
            $TYPE(x::UETY{ùóΩ,$ùëëMO}) where ùóΩ<:PREC = new{ùóΩ,EX,MO}(_qty(uconvert($uMO, x)))
            # United Measurement (UMTY) constructors
            $TYPE(x::UMTY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,MM,SY}(_qty(uconvert($uSY, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëDT}) where ùóΩ<:PREC = new{ùóΩ,MM,DT}(_qty(uconvert($uDT, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëMA}) where ùóΩ<:PREC = new{ùóΩ,MM,MA}(_qty(uconvert($uMA, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëMO}) where ùóΩ<:PREC = new{ùóΩ,MM,MO}(_qty(uconvert($uMO, x)))
        end
        # Type documentation
        @doc $dcStr $TYPE
        # Precision-changing external constructors
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,EX,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(ùòÄ(x.amt.val), ùóØ)
        end
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,MM,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(Measurement{ùòÄ}(x.amt.val), ùóØ)
        end
        # Precision+Exactness-changing external constructors
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,EX,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(ùòÄ(x.amt.val), ùóØ)
        end
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,MM,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(ùòÄ(x.amt.val.val), ùóØ)
        end
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,EX,ùóØ},
                            e::ùòÄ=ùòÄ(max(eps(ùòÄ),eps(x.amt.val)))
                            ) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(measurement(ùòÄ(x.amt.val), e), ùóØ)
        end
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,MM,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(Measurement{ùòÄ}(x.amt.val), ùóØ)
        end
        # Type export
        export $TYPE
        # Type-specific functions
        deco(x::$TYPE{ùóΩ,ùòÖ,SY} where {ùóΩ,ùòÖ}) = Symbol($ùë†SY)
        deco(x::$TYPE{ùóΩ,ùòÖ,DT} where {ùóΩ,ùòÖ}) = Symbol($ùë†DT)
        deco(x::$TYPE{ùóΩ,ùòÖ,MA} where {ùóΩ,ùòÖ}) = Symbol($ùë†MA)
        deco(x::$TYPE{ùóΩ,ùòÖ,MO} where {ùóΩ,ùòÖ}) = Symbol($ùë†MO)
        ppu(x::$TYPE{ùóΩ,ùòÖ,SY} where {ùóΩ,ùòÖ}) = $USTR
        ppu(x::$TYPE{ùóΩ,ùòÖ,DT} where {ùóΩ,ùòÖ}) = $USTR * "/s"
        ppu(x::$TYPE{ùóΩ,ùòÖ,MA} where {ùóΩ,ùòÖ}) = $USTR * "/kg"
        ppu(x::$TYPE{ùóΩ,ùòÖ,MO} where {ùóΩ,ùòÖ}) = $USTR * "/kmol"
        # Indirect construction from plain
        $FNAM(x::plnF, b::Type{ùóØ}=DEF[:IB]) where ùóØ<:BASE = $TYPE(x, b)
        $FNAM(x::plnR, b::Type{ùóØ}=DEF[:IB]) where ùóØ<:BASE = $TYPE(float(x), b)
        # Indirect construction from quantity
        $FNAM(x::Union{UATY{ùóΩ,$ùëëSY},UATY{ùóΩ,$ùëëDT},
                       UATY{ùóΩ,$ùëëMA},UATY{ùóΩ,$ùëëMO}}) where ùóΩ<:PREC = begin
            $TYPE(x)
        end
        $FNAM(x::Union{uniR{ùóΩ,$ùëëSY},uniR{ùóΩ,$ùëëDT},
                       uniR{ùóΩ,$ùëëMA},uniR{ùóΩ,$ùëëMO}}) where ùóΩ<:REAL = begin
            $TYPE(float(x.val) * unit(x))
        end
        export $FNAM
        # Conversions - Change of base is _not_ a conversion
        # Same {EXAC,BASE}, {PREC}- conversion
        convert(::Type{$TYPE{ùòÄ,ùòÖ,ùóØ}},
                y::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),ùòÖ}(y)
        end
        # Same {BASE}, {PREC,EXAC}- conversion
        convert(::Type{$TYPE{ùòÄ,ùòÜ,ùóØ}},
                y::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC,ùóØ<:BASE} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}(y)
        end
        # Promotion rules
        promote_rule(::Type{$TYPE{ùòÄ,ùòÜ,ùóØ}},
                     ::Type{$TYPE{ùóΩ,ùòÖ,ùóØ}}) where {ùòÄ<:PREC,ùóΩ<:PREC,
                                                  ùòÜ<:EXAC,ùòÖ<:EXAC,ùóØ<:BASE} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ),ùóØ}
        end
    end
end


#----------------------------------------------------------------------------------------------#
#                           Thermodynamic Amount Group Declarations                            #
#----------------------------------------------------------------------------------------------#

# Mass / Mass fraction anomalous
mkBasAmt(:mAmt  , :BProperty, :m    , "m"   , u"kg"         , "kg"      , "mass"                , false , bsym=(:m , :mÃá , :mf, :M))
# Chemical amount / Molar fraction anomalous
mkBasAmt(:nAmt  , :BProperty, :N    , "N"   , u"kmol"       , "kmol"    , "chemical amount"     , false , bsym=(:N , :NÃá , :n , :y))
# Gas constant / System constant anomalous
mkBasAmt(:RAmt  , :BProperty, :R    , "mR"  , u"kJ/K"       , "kJ/K"    , "gas constant"        , false , bsym=(:mR, :mÃáR, :R , :RÃÑ))
# Plank function anomalous
mkBasAmt(:rAmt  , :BProperty, :r    , "mr"  , u"kJ/K"       , "kJ/K"    , "Planck function"     , false , bsym=(:mr, :mÃár, :r , :rÃÑ))

# Regular properties
mkBasAmt(:uAmt  , :BProperty, :u    , "U"   , u"kJ"         , "kJ"      , "internal energy"     , false )
mkBasAmt(:hAmt  , :BProperty, :h    , "H"   , u"kJ"         , "kJ"      , "enthalpy"            , false )
mkBasAmt(:gAmt  , :BProperty, :g    , "G"   , u"kJ"         , "kJ"      , "Gibbs energy"        , false )
mkBasAmt(:aAmt  , :BProperty, :a    , "A"   , u"kJ"         , "kJ"      , "Helmholtz energy"    , false )
mkBasAmt(:eAmt  , :BProperty, :e    , "E"   , u"kJ"         , "kJ"      , "total energy"        , false )
mkBasAmt(:ekAmt , :BProperty, :ek   , "Ek"  , u"kJ"         , "kJ"      , "kinetic energy"      , false )
mkBasAmt(:epAmt , :BProperty, :ep   , "Ep"  , u"kJ"         , "kJ"      , "potential energy"    , false )
mkBasAmt(:sAmt  , :BProperty, :s    , "S"   , u"kJ/K"       , "kJ/K"    , "entropy"             , false )
mkBasAmt(:cpAmt , :BProperty, :cp   , "Cp"  , u"kJ/K"       , "kJ/K"    , "iso-P specific heat" , false )
mkBasAmt(:cvAmt , :BProperty, :cv   , "Cv"  , u"kJ/K"       , "kJ/K"    , "iso-v specific heat" , false )
mkBasAmt(:jAmt  , :BProperty, :j    , "J"   , u"kJ/K"       , "kJ/K"    , "Massieu function"    , false )

# Regular interactions
mkBasAmt(:qAmt  , :BInteract, :q    , "Q"   , u"kJ"         , "kJ"      , "heat"                , false )
mkBasAmt(:wAmt  , :BInteract, :w    , "W"   , u"kJ"         , "kJ"      , "work"                , false )
mkBasAmt(:ŒîeAmt , :BInteract, :Œîe   , "E"   , u"kJ"         , "kJ"      , "energy variation"    , true  )
mkBasAmt(:ŒîsAmt , :BInteract, :Œîs   , "S"   , u"kJ/K"       , "kJ/K"    , "entropy variation"   , true  )


#----------------------------------------------------------------------------------------------#
#                                       Pretty Printing                                        #
#----------------------------------------------------------------------------------------------#

import Base: show
import Formatting: sprintf1


# Auxiliar method
function subscript(x::Int)
    asSub(c::Char) = Char(Int(c) - Int('0') + Int('‚ÇÄ'))
    map(asSub, "$(x)")
end

# Precision decoration
pDeco(::Type{Float16})  = DEF[:showPrec] ? subscript(16) : ""
pDeco(::Type{Float32})  = DEF[:showPrec] ? subscript(32) : ""
pDeco(::Type{Float64})  = DEF[:showPrec] ? subscript(64) : ""
pDeco(::Type{BigFloat}) = DEF[:showPrec] ? subscript(precision(BigFloat)) : ""

# Custom printing
Base.show(io::IO, x::AMOUNTS{ùóΩ,EX}) where ùóΩ<:PREC = begin
    print(io,
          "$(string(deco(x)))$(pDeco(ùóΩ)): ",
          sprintf1("%.$(DEF[:showSigD])g", x.amt.val),
          " ", ppu(x))
    # Formatting string is hardcoded apparently because @sprintf is a macro!
end

Base.show(io::IO, x::AMOUNTS{ùóΩ,MM}) where ùóΩ<:PREC = begin
    print(io,
          "$(string(deco(x)))$(pDeco(ùóΩ)): (",
          sprintf1("%.$(DEF[:showSigD])g", x.amt.val.val),
          " ¬± ",
          sprintf1("%.2g", x.amt.val.err),
          ") ", ppu(x))
    # Formatting string is hardcoded apparently because @sprintf is a macro!
end


